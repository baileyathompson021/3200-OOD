/*
 * arithS.cs
 * 
 * Bailey Thompson
 * 28 October 2019
 * Version 1
 * 
 * Class Overview: 
 * > Program that creates artithS objects with available public functions numGen(), reset(), getMode(), switchMode(), queryModeSwitches(), next(), 
 *   genNextNum(), setForbiddenSet()
 * 
 * Interface Invariant: 
 * > arithS object is initialized in Advance mode
 *   Change of mode depends on amount of times next() function is called
 *   Once amount of calls to next() exceeds threshold, an object goes into a forbidden state
 * > Constructor takes in integer that is to be used as the common difference for the generation of the arithmetic sequence.
 *   The first number in every arithS sequence is 1
 *   For example: If the common difference is set as 2 in the constructor, the sequence will be generated as following: 1, 2, 4, 6...
 *   Constructor initilaizes the forbiddenSet to be null
 *   No argument constructor initializes the common difference to be 2
 * > Generation of the arithmetic sequence is dependent upon what mode the object is in
 *   Integer returned by next() function depends on the mode of the object
 *   Advance generates and returns the next number in the sequence
 *   Retreat returns the previous number in the sequence 
 *   No new numbers are generated, so subsequent calls to retreat will continue to receive the same number
 *   (if user has not yet called called a next() call while the object was in a different mode, -1 is returned) 
 *   Stuck returns the current number in the sequence
 * > If the object is in 'forbidden' state and the integer to be generated by a call to next() is in the forbidden set, -1 is returned by a call to next()
 *   Since an accurate call to next() may also yield -1, it is unknown by the user which one is the case
 *   Object must be reset() to get out of 'forbidden' state
 * 
 * Class Invariant: 
 * > forbiddenSet is an array of integers that can be changed or nulled by the user at any time
 *   The generation of the arithmetic sequence is dependent upon the forbiddenSet and what numbers are in it as well as what mode the object is in
 *   If amount of calls to next() exceeds a certain threshold (5), arithS object goes into 'forbidden' state
 *   Once the object is in 'forbidden' state, if the next number to be returned by the next() function is contained in the forbiddenSet, the 
 *   number is not returned, but instead -1
 * > getMode() returns the mode along with 'forbidden' if the object is in a forbidden state
 * > numGen() returns how many values have been generated in the sequence
 * > switchMode() switches the mode of the arithS object in the following way:
 *   Advance->Retreat->Stuck
 *   Mode switching is an external only transition
 * > reset() resets all functionality of the arithS object back to as if it were first initialized except for that it still keeps whatever forbidden set
 *   was created.
 *   No mode switches, mode is set to Advance, no previous numbers generated
 * > queryModeSwitches() returns how many times the mode has been switched
 * > There is no check for how many times next has been called, it is the user's responsibility to keep track of how many times they are calling it
 * 
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace P3
{
    public class arithS
    {
        private int commonDifference;
        private int[] forbiddenSet;
        private static int threshold = 5; //arbitrary value for the threshold of arithS objects

        protected int nextCalls;
        protected int valuesGenerated;
        protected int currNum, prevNum;
        protected int mode;
        protected int modeNum = 3; //amount of modes in arithS object class. For extensibility

        public arithS()
        {
            commonDifference = 2;
            forbiddenSet = null;
            prevNum = 0;
            currNum = 1;
            nextCalls = 0;
            valuesGenerated = 0;
            mode = 0;
        }
        public arithS(int commonDifference)
        {
            this.commonDifference = commonDifference;
            forbiddenSet = null;
            prevNum = 0;
            currNum = 1;
            nextCalls = 0;
            valuesGenerated = 0;
            mode = 0;
        }
        public int numGen()
        {
            return valuesGenerated;
        }
        public virtual void setForbiddenSet(int[] forbiddenSet)
        {
            this.forbiddenSet = forbiddenSet;
        }
        public void reset()
        {
            nextCalls = 0;
            mode = 0;
            valuesGenerated = 0;
            currNum = 1;
            prevNum = 0;
        }
        public virtual string getMode()
        {
            string ans = "";
            if (nextCalls > threshold)
                ans += "forbidden ";
            if (mode % modeNum == 0)
                ans += "advance";
            else if (mode % modeNum == 1)
                ans += "retreat";
            else
                ans += "stuck";
            return ans;
        }
        public void switchMode()
        {
            if (checkForbidden(currNum)) return;
            mode++;
        }
        public int queryModeSwitches()
        {
            return mode;
        }
        public virtual int next()
        {
            nextCalls++;
            if (mode % modeNum == 0)
            {
                genNextNum();
                if (checkForbidden(currNum)) return -1;
                return currNum;
            }
            else if (mode % modeNum == 1)
            {
                if (nextCalls == 0 || checkForbidden(prevNum))
                    return -1;
                return prevNum;
            }
            else
            {
                return currNum;
            }
        }
        private bool checkForbidden(int cNum)
        {
            if ((nextCalls < threshold) || (forbiddenSet == null)) return false;
            for (int i = 0; i < forbiddenSet.Length; i++)
                if (cNum == forbiddenSet[i]) return true;
            return false;
        }
        protected virtual void genNextNum()
        {
            valuesGenerated++;
            prevNum = currNum;
            currNum = (nextCalls) * commonDifference;
        }
    }
}
/*
 * Implementation Invariant: 
 * > Generation of arithmetic sequence uses Property Injection as the generation of the sequence is dependent on the values set in the 
 *   setForbiddenSet() method.
 *   Dependency is optional, so if no array is set in the function then the arithS will not have a forbiddenSet and values will all be generated
 *   as normal.
 *   This method is made virtual in case child classes wanted to make changes to how the forbidden set is generated within the class
 * > Constructors initialize forbiddenSet to null and methods check within them whether or not the set is null before deciding what value to return
 * > Generation of the arithmetic sequence is dependent upon what mode the object is in
 *   Integer returned by next() function depends on the mode of the object
 *   Advance generates and returns the next number in the sequence
 *   Retreat returns the previous number in the sequence (if user has not yet called called a next() call while the object was in a different mode, 
 *   -1 is returned) 
 *   Stuck returns the current number in the sequence
 * > Once next calls exceeds a certain threshold, object goes into 'forbidden' state
 *   threshold is a stable, internal integer arbitrarily set at 5 within the class
 * > If the object is in 'forbidden' state, and the next number is in the forbidden set -1 is returned by a call to next()
 *   Since an accurate call to next() may also yield -1, it is unknown by the user which one is the case
 *   Chose to return -1 instead of throw an exception so object can still be used and possibly reset
 *   In order to get out of forbidden state, object must be reset
 * > The first number in every arithmetic sequence is initialized at 1.
 * > next() is made virtual in case more modes are added in child classes or a child class wishes to change when the sequence is generated
 * > switchMode() adds 1 to what mode the object is in
 *   Mode is not switched if the current number in the arithmetic sequence is forbidden.
 * > getMode() returns a string of what mode the object is in
 *   When called, returns the mod value of the integer 'mode' to how many modes there are (modeCount) - Done in case more modes are added, so there 
 *   would be minimal change to function.
 *   Also done so what mode the object is in and how many mode switches have been called are kept track of by the same variable.
 *   This method is made virtual in case child classes want to add different modes to the class.
 * > queryModeSwitches() returns how many times user has switched modes.
 * > reset() resets mode of arithS object back to 0 (Advance mode) as well as all other functionality except for the forbiddenSet
 *   resets the amount of calls to next() function back to 0.
 * > checkForbidden() is a protected method that returns true when the number passed in is in the forbidden set and the number of calls to
 *   next has exceeded the threshold.
 *   next(), switchMode(), and getMode() are dependent on this function to check whether or not the number that is supposed to be returned
 *   is in the forbiddenSet
 *   Child classes do not need access to this function since they already have access to the forbidden set and nextCount integer in case changes 
 *   want to be made.
 * > genNextNum() is a helper function for next()
 *   next() is dependent on this function, as it generates the next number in the sequence when asked
 *   Keeps track of both the current number in the arithmetic sequence, and the previous
 *   Keeps track of how many values have been generated, since when an object is in stuck/retreat mode numbers in the sequence are not generated
 * > 
 */
